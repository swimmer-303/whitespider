/*!
 * phaser-super-storage - version 1.0.4 
 * A cross platform storage plugin for Phaser
 *
 * OrangeGames
 * Build at 02-10-2017
 * Released under MIT License 
 */

// Define the CookieStorage class
class CookieStorage {
  constructor(namespace) {
    this.namespace = namespace || "";
    this.reg = null;
  }

  // Get the length of stored items
  get length() {
    return this.getNameSpaceMatches().length;
  }

  // Get the item with the given key
  getItem(key) {
    const c = this.getCookiesForNameSpace()[key] || null;
    return this.forcePromises ? this.promisefy(c) : c;
  }

  // Set the item with the given key and value
  setItem(key, value) {
    document.cookie =
      encodeURIComponent(this.namespace + key) +
      "=" +
      encodeURIComponent(value) +
      "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
    if (this.forcePromises) return this.promisefy(null);
    return null;
  }

  // Remove the item with the given key
  removeItem(key) {
    document.cookie =
      encodeURIComponent(this.namespace + key) +
      "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
    if (this.forcePromises) return this.promisefy(null);
    return null;
  }

  // Clear all stored items
  clear() {
    const cookies = this.getCookiesForNameSpace();
    for (const key in cookies) {
      this.removeItem(key);
    }
    if (this.forcePromises) return this.promisefy(null);
    return null;
  }

  // Set the namespace
  setNamespace(namespace) {
    if (namespace && (this.namespace = namespace + ":")) {
      this.reg = new RegExp("^" + this.namespace + "[a-zA-Z0-9]*", "g");
    }
    if (this.forcePromises) return this.promisefy(namespace);
    return null;
  }

  // Get the matches for the namespace in the cookies
  getNameSpaceMatches() {
    const matches = [];
    const reg = this.reg;
    const cookies = decodeURIComponent(document.cookie).split("; ");

    for (const cookie of cookies) {
      if (null !== cookie.match(reg) && cookie.match(reg).length > 0) {
        matches.push(cookie);
      }
    }

    return matches;
  }

  // Get the cookies for the namespace
  getCookiesForNameSpace() {
    const cookies = {};
    const matches = this.getNameSpaceMatches();

    for (const match of matches) {
      const parts = match.replace(this.namespace, "").split("=");
      cookies[parts[0]] = parts[1];
    }

    return cookies;
  }

  // Promisify a value
  promisefy(value) {
    return new Promise((resolve) => resolve(value));
  }
}

// Define the CordovaStorage class
class CordovaStorage {
  constructor(namespace) {
    this.namespace = namespace || "";
    this.keys = [];
  }

  // Get the length of stored items
  get length() {
    return this.keys.length;
  }

  // Get the item with the given key
  getItem(key) {
    return new Promise((resolve, reject) => {
      NativeStorage.getItem(this.namespace + key, (value) => {
        resolve(value);
      }, (error) => {
        if (error.code === 2) {
          resolve(null);
        } else {
          reject(error);
        }
      });
    });
  }

  // Set the item with the given key and value
  setItem(key, value) {
    if (key.length < 1) {
      console.error("CordovaStorage: Key cannot be an empty string!");
    }

    return new Promise((resolve, reject) => {
      NativeStorage.setItem(
        this.namespace + key,
        value,
        () => {
          if (this.keys.indexOf(key) < 0) {
            this.keys.push(key);
            this.save();
          }
          resolve(null);
        },
        (error) => {
          reject(error);
        }
      );
    });
  }

  // Remove the item with the given key
  removeItem(key) {
    return new Promise((resolve, reject) => {
      NativeStorage.remove(
        this.namespace + key,
        () => {
          const index = this.keys.indexOf(key);
          if (index >= 0) {
            this.keys.splice(index, 1);
            this.save();
          }
          resolve(null);
        },
        (error) => {
          reject(error);
        }
      );
    });
  }

  // Clear all stored items
  clear() {
    return new Promise((resolve, reject) => {
      let count = 0;
      for (const key of this.keys) {
        NativeStorage.remove(
          this.namespace + key,
          () => {
            count++;
            if (count === this.keys.length) {
              this.keys = [];
              this.save();
              resolve(null);
            }
          },
          (error) => {
            reject(error);
          }
        );
      }
    });
  }

  // Set the namespace
  setNamespace(namespace) {
    if (void 0 === namespace) {
      namespace = "";
    }
    this.namespace = namespace + ":";
    this.keys = [];
    this.load();
  }

  // Load stored keys from NativeStorage
  load() {
    return new Promise((resolve, reject) => {
      NativeStorage.getItem(this.namespace, (value) => {
        this.keys = JSON.parse(value);
        resolve(null);
      }, (error) => {
        reject(error);
      });
    });
  }

  // Save keys to NativeStorage
  save() {
    NativeStorage.setItem(
      this.namespace,
      JSON.stringify(this.keys),
      () => {},
      (error) => {
        console.warn("CordovaStorage: Failed to save keys of namespace.");
      }
    );
  }
}

// Define the IframeStorage class
class IframeStorage {
  constructor(namespace, expectedOrigin) {
    this.namespace = "";
    this.expectedOrigin = "";
    this.storageLength = 0;
    this.enabled = false;
    this.setNamespace(namespace);
    this.expectedOrigin = expectedOrigin || "*";
  }

  // Get the length of stored items
  get length() {
    return this.storageLength;
  }

  // Initialize the storage
  init() {
    return this.sendMessage({ command: a.StorageCommand.init });
  }

  // Get the key with the given index
  key(index) {
    return this.sendMessage({ command: a.StorageCommand.key, value: index });
  }

  // Get the item with the given key
  getItem(key) {
    return this.sendMessage({ command: a.StorageCommand.getItem, key });
  }

  // Set the item with the given key and value
  setItem(key, value) {
    return this.sendMessage({ command: a.StorageCommand.setItem, key, value });
  }

  // Remove the item with the given key
  removeItem(key) {
    return this.sendMessage({ command: a.StorageCommand.removeItem, key });
  }

  // Clear all stored items
  clear() {
    return this.sendMessage({ command: a.StorageCommand.clear });
  }

  // Set the namespace
  setNamespace(namespace) {
    if ("" !== namespace) {
      this.namespace = namespace + ":";
    }
  }

  // Send a message to the parent window
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      const messageChannel = new MessageChannel();
      const port = messageChannel.port1;

      port.onmessage = (event) => {
        const response = a.StorageUtils.validateMessage(event.data);

        switch (response.command) {
          case a.StorageCommand.init:
            this.enabled = true;
            resolve(response.status);
            break;
          case a.StorageCommand.getItem:
          case a.StorageCommand.length:
          case a.StorageCommand.key:
            resolve(response.value);
            break;
          case a.StorageCommand.setItem:
          case a.StorageCommand.removeItem:
          case a.StorageCommand.clear:
          case a.StorageCommand.init:
            resolve(response.status);
            break;
          default:
            reject(response.value);
        }
      };

      if (this.enabled || message.command === a.StorageCommand.init) {
        window.parent.postMessage(message, this.expectedOrigin, [messageChannel.port2]);
      } else {
        reject("Messaging not enabled!");
      }
    });
  }
}

// Define the LocalStorage class
class LocalStorage {
  constructor(namespace) {
    this.namespace = "";
    this.forcePromises = false;
    this.setNamespace(namespace);
  }

  // Get the length of stored items
  get length() {
    const keys = Object.keys(localStorage);
    return a.StorageUtils.nameSpaceKeyFilter(keys, this.namespace).length;
  }

  // Get the key with the given index
  key(index) {
    if (this.forcePromises) {
      return this.promisefy(this._key, arguments);
    } else {
      return this._key(index);
    }
  }

  _key(index) {
    const keys = Object.keys(localStorage);
    const filteredKeys = a.StorageUtils.nameSpaceKeyFilter(keys, this.namespace);
    return filteredKeys[index];
  }

  // Get the item with the given key
  getItem(key) {
    if (this.forcePromises) {
      return this.promisefy(this._getItem, arguments);
    } else {
      return this._getItem(key);
    }
  }

  _getItem(key) {
    return localStorage.getItem(this.namespace + key);
  }

  // Set the item with the given key and value
  setItem(key, value) {
    if (this.forcePromises) {
      return this.promisefy(this._setItem, arguments);
    } else {
      return this._setItem(key, value);
    }
  }

  _setItem(key, value) {
    return localStorage.setItem(this.namespace + key, value);
  }

  // Remove the item with the given key
  removeItem(key) {
    if (this.forcePromises) {
      return this.promisefy(this._removeItem, arguments);
    } else {
      return this._removeItem(key);
    }
  }

  _removeItem(key) {
    return localStorage.removeItem(this.namespace + key);
  }

  // Clear all stored items
  clear() {
    if (this.forcePromises) {
      return this.promisefy(this._clear, arguments);
    } else {
      return this._clear();
    }
  }

  _clear() {
    const keys = Object.keys(localStorage);
    const filteredKeys = a.StorageUtils.nameSpaceKeyFilter(keys, this.namespace);

    for (const key of filteredKeys) {
      localStorage.removeItem(key);
    }
  }

  // Set the namespace
  setNamespace(namespace) {
    if (this.forcePromises) {
      this.promisefy(this._setNameSpace, arguments);
    } else {
      this._setNameSpace(namespace);
    }
  }

  _setNameSpace(namespace) {
    if (namespace) {
      this.namespace = namespace + ":";
    }
  }

  // Promisify a function
  promisefy(fn, args) {
    return new Promise((resolve, reject) => {
      resolve(fn.apply(this, args));
    });
  }
}

// Define the Storage class
class Storage {
  constructor(adapter) {
    if (void 0 !== adapter) {
      Object.defineProperty(adapter, "storage", { value: this });
    } else {
      if (null !== Storage.instance) {
        return Storage.instance;
      }
      if (a.StorageUtils.isLocalStorageSupport()) {
        this.setAdapter(new a.StorageAdapters.LocalStorage());
      } else {
        this.setAdapter(new a.StorageAdapters.CookieStorage());
      }
    }
  }

  // Set the adapter
  setAdapter(adapter) {
    this.storage = adapter;
  }

  // Get the length of stored items
  get length() {
    return null === this.storage ? 0 : this.storage.length;
  }

  // Set the namespace
  setNamespace(namespace) {
    if (null !== this.storage) {
      return this.storage.setNamespace(namespace);
    }
  }

  // Get the key with the given index
  key(index) {
    return null === this.storage ? "" : this.storage.key(index);
  }

  // Get the item with the given key
  getItem(key) {
    return null === this.storage ? null : this.storage.getItem(key);
  }

  // Set the item with the given key and value
  setItem(key, value) {
    if (null !== this.storage) {
      return this.storage.setItem(key, value);
    }
  }

  // Remove the item with the given key
  removeItem(key) {
    if (null !== this.storage) {
      return this.storage.removeItem(key);
    }
  }

  // Clear all stored items
  clear() {
    if (null !== this.storage) {
      return this.storage.clear();
    }
  }
}

// Define the StorageCommand enumeration
const StorageCommand = Object.freeze({
  init: 0,
  setItem: 1,
  getItem: 2,
  removeItem: 3,
  clear: 4,
  setNamespace: 5,
  length: 6,
  key: 7,
  error: 8,
});

// Define the StorageUtils class
const StorageUtils = (() => {
  const isLocalStorageSupport = () => {
    try {
      if ("object" === typeof localStorage) {
        localStorage.setItem("testingLocalStorage", "foo");
        localStorage.removeItem("testingLocalStorage");
        return true;
      }
    } catch (error) {
      return false;
    }
    return false;
  };

  const validateMessage = (message) =>
    message.hasOwnProperty("command") ? message : null;

  const nameSpaceKeyFilter = (keys, namespace) =>
    keys.filter((key) => key.substring(0, namespace.length) === namespace);

  return {
    isLocalStorageSupport,
    validateMessage,
    nameSpaceKeyFilter,
  };
})();
