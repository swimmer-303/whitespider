/*!
 * phaser-super-storage - version 1.0.4 
 * A cross platform storage plugin for Phaser
 *
 * OrangeGames
 * Build at 02-10-2017
 * Released under MIT License 
 */

// Define the CookieStorage class
class CookieStorage {
  constructor(namespace) {
    this.namespace = namespace || "";
    this.reg = null;
  }

  // Get the length of stored items
  get length() {
    return this.getNameSpaceMatches().length;
  }

  // Get the item with the given key
  getItem(key) {
    const c = this.getCookiesForNameSpace()[key] || null;
    return this.forcePromises ? this.promisefy(c) : c;
  }

  // Set the item with the given key and value
  setItem(key, value) {
    if (key.length < 1) {
      console.error("CordovaStorage: Key cannot be an empty string!");
      return this.promisefy(null);
    }

    document.cookie =
      encodeURIComponent(this.namespace + key) +
      "=" +
      encodeURIComponent(value) +
      "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";

    if (this.forcePromises) return this.promisefy(null);
  }

  // Remove the item with the given key
  removeItem(key) {
    document.cookie =
      encodeURIComponent(this.namespace + key) +
      "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";

    if (this.forcePromises) return this.promisefy(null);
  }

  // Clear all stored items
  clear() {
    const cookies = this.getCookiesForNameSpace();

    for (const key in cookies) {
      if (cookies.hasOwnProperty(key)) this.removeItem(key);
    }

    if (this.forcePromises) return this.promisefy(null);
  }

  // Set the namespace
  setNamespace(namespace) {
    if (namespace) {
      this.namespace = namespace + ":";
      this.reg = new RegExp("^" + this.namespace + "[a-zA-Z0-9]*", "g");
    }

    if (this.forcePromises) return this.promisefy(null);
  }

  // Get the matches of the namespace in the cookies
  getNameSpaceMatches() {
    const matches = [];
    const cookies = decodeURIComponent(document.cookie).split("; ");

    for (const cookie of cookies) {
      if (cookie.match(this.reg) && cookie.match(this.reg).length > 0) {
        matches.push(cookie);
      }
    }

    return matches;
  }

  // Get the cookies for the current namespace
  getCookiesForNameSpace() {
    const cookies = {};

    for (const keyValue of this.getNameSpaceMatches()) {
      const [key, value] = keyValue.replace(this.namespace, "").split("=");
      cookies[key] = value;
    }

    return cookies;
  }

  // Promisify a value
  promisefy(value) {
    return new Promise((resolve) => resolve(value));
  }
}

// Define the CordovaStorage class
class CordovaStorage {
  constructor(namespace) {
    this.namespace = namespace || "";
    this.keys = [];
  }

  // Get the length of stored items
  get length() {
    return this.keys.length;
  }

  // Get the item with the given key
  getItem(key) {
    return new Promise((resolve, reject) => {
      NativeStorage.getItem(this.namespace + key, (value) => {
        if (2 === value.code) {
          resolve(null);
        } else {
          resolve(value);
        }
      }, reject);
    });
  }

  // Set the item with the given key and value
  setItem(key, value) {
    if (key.length < 1) {
      console.error("CordovaStorage: Key cannot be an empty string!");
      return this.promisefy(null);
    }

    return new Promise((resolve, reject) => {
      NativeStorage.setItem(
        this.namespace + key,
        value,
        () => {
          this.keys.indexOf(key) < 0 && this.keys.push(key);
          this.save();
          resolve(null);
        },
        reject
      );
    });
  }

  // Remove the item with the given key
  removeItem(key) {
    return new Promise((resolve, reject) => {
      NativeStorage.remove(
        this.namespace + key,
        () => {
          const index = this.keys.indexOf(key);
          index >= 0 && this.keys.splice(index, 1);
          this.save();
          resolve(null);
        },
        reject
      );
    });
  }

  // Clear all stored items
  clear() {
    return new Promise((resolve, reject) => {
      for (let i = 0; i < this.keys.length; i++) {
        NativeStorage.remove(
          this.namespace + this.keys[i],
          () => {
            if (i >= this.keys.length - 1) {
              this.keys = [];
              this.save();
              resolve(null);
            }
          },
          reject
        );
      }
    });
  }

  // Set the namespace
  setNamespace(namespace) {
    if (void 0 === namespace) {
      namespace = "";
    }

    this.namespace = namespace + ":";
    this.keys = [];

    return new Promise((resolve, reject) => {
      this.load().then(resolve)["catch"](resolve);
    });
  }

  // Load keys from storage
  load() {
    return new Promise((resolve, reject) => {
      NativeStorage.getItem(this.namespace, (value) => {
        this.keys = JSON.parse(value);
        resolve(null);
      }, reject);
    });
  }

  // Save keys to storage
  save() {
    NativeStorage.setItem(
      this.namespace,
      JSON.stringify(this.keys),
      () => {},
      (error) => {
        console.warn(
          "CordovaStorage: Failed to save keys of namespace."
        );
      }
    );
  }
}

// Define the IframeStorage class
class IframeStorage {
  constructor(namespace, expectedOrigin = "*") {
    this.namespace = "";
    this.expectedOrigin = expectedOrigin;
    this.storageLength = 0;
    this.enabled = false;

    if (namespace) this.setNamespace(namespace);
    this.init();
  }

  // Get the length of stored items
  get length() {
    return this.storageLength;
  }

  // Initialize the storage
  async init() {
    await this.sendMessage({ command: StorageCommand.init });
    this.enabled = true;
  }

  // Get the item with the given key
  async getItem(key) {
    return await this.sendMessage({ command: StorageCommand.getItem, key });
  }

  // Set the item with the given key and value
  async setItem(key, value) {
    return await this.sendMessage({ command: StorageCommand.setItem, key, value });
  }

  // Remove the item with the given key
  async removeItem(key) {
    return await this.sendMessage({ command: StorageCommand.removeItem, key });
  }

  // Clear all stored items
  async clear() {
    return await this.sendMessage({ command: StorageCommand.clear });
  }

  // Set the namespace
  setNamespace(namespace) {
    this.namespace = namespace + ":";
  }

  // Send a message to the parent window
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      const messageChannel = new MessageChannel();
      const port = messageChannel.port2;

      messageChannel.port1.onmessage = (event) => {
        const response = StorageUtils.validateMessage(event.data);

        if (response.hasOwnProperty("status") && "ok" === response.status) {
          if (response.hasOwnProperty("length")) {
            this.storageLength = response.length;
          }

          switch (response.command) {
            case StorageCommand.setNamespace:
            case StorageCommand.getItem:
            case StorageCommand.length:
            case StorageCommand.key:
              resolve(response.value);
              break;

            case StorageCommand.setItem:
            case StorageCommand.removeItem:
            case StorageCommand.clear:
            case StorageCommand.init:
              resolve(response.status);
              break;

            default:
              reject(response.value);
          }
        } else {
          reject(response.value);
        }
      };

      if (this.enabled || message.command === StorageCommand.init) {
        window.parent.postMessage(message, this.expectedOrigin, [port]);
      } else {
        reject("Messaging not enabled!");
      }
    });
  }
}

// Define the LocalStorage class
class LocalStorage {
  constructor(namespace) {
    this.namespace = namespace || "";
    this.forcePromises = false;
  }

  // Get the length of stored items
  get length() {
    const keys = Object.keys(localStorage);
    return StorageUtils.nameSpaceKeyFilter(keys, this.namespace).length;
  }

  // Get the item with the given key
  getItem(key) {
    return this.forcePromises
      ? this.promisefy(this._getItem, [key])
      : this._getItem(key);
  }

  // Get the raw item with the given key
  _getItem(key) {
    const keys = Object.keys(localStorage);
    const filteredKeys = StorageUtils.nameSpaceKeyFilter(keys, this.namespace);
    return localStorage.getItem(filteredKeys[key]);
  }

  // Set the item with the given key and value
  setItem(key, value) {
    return this.forcePromises
      ? this.promisefy(this._setItem, [key, value])
      : this._setItem(key, value);
  }

  // Set the raw item with the given key and value
  _setItem(key, value) {
    localStorage.setItem(this.namespace + key, value);
  }

  // Remove the item with the given key
  removeItem(key) {
    return this.forcePromises
      ? this.promisefy(this._removeItem, [key])
      : this._removeItem(key);
  }

  // Remove the raw item with the given key
  _removeItem(key) {
    localStorage.removeItem(this.namespace + key);
  }

  // Clear all stored items
  clear() {
    const keys = Object.keys(localStorage);
    const filteredKeys = StorageUtils.nameSpaceKeyFilter(keys, this.namespace);

    for (let i = 0; i < filteredKeys.length; i++) {
      localStorage.removeItem(filteredKeys[i]);
    }
  }

  // Set the namespace
  setNamespace(namespace) {
    this.namespace = namespace + ":";
  }

  // Promisify a function
  promisefy(fn, args) {
    return new Promise((resolve) => resolve(fn.apply(this, args)));
  }
}

// Define the Storage class
class Storage {
  constructor(adapter) {
    if (adapter) {
      this.adapter = adapter;
    } else {
      if (StorageUtils.isLocalStorageSupport()) {
        this.adapter = new StorageAdapters.LocalStorage();
      } else {
        this.adapter = new StorageAdapters.CookieStorage();
      }
    }

    Object.defineProperty(this, "forcePromises", {
      get: () => this.adapter.forcePromises,
      set: (value) => (this.adapter.forcePromises = value),
    });

    Object.defineProperty(this, "length", {
      get: () => this.adapter.length,
      enumerable: true,
      configurable: true,
    });
  }

  // Set the namespace
  setNamespace(namespace) {
    this.adapter.setNamespace(namespace);
  }

  // Get the item with the given key
  getItem(key) {
    return this.adapter.getItem(key);
  }

  // Set the item with the given key and value
  setItem(key, value) {
    this.adapter.setItem(key, value);
  }

  // Remove the item with the given key
  removeItem(key) {
    this.adapter.removeItem(key);
  }

  // Clear all stored items
  clear() {
    this.adapter.clear();
  }
}

// Define the StorageCommand enumeration
const StorageCommand = {
  init: 0,
  setItem: 1,
  getItem: 2,
  removeItem: 3,
  clear: 4,
  setNamespace: 5,
  length: 6,
  key: 7,
  error: 8,
};

// Define the StorageUtils class
const StorageUtils = {
  isLocalStorageSupport: function () {
    try {
      if ("object" === typeof localStorage) {
        localStorage.setItem("testingLocalStorage", "foo");
        localStorage.removeItem("testingLocalStorage");
        return true;
      }
    } catch (error) {
      return false;
    }

    return false;
  },

  validateMessage: function (message) {
    return message.hasOwnProperty("command") ? message : null;
  },

  nameSpaceKeyFilter: function (keys, namespace) {
    return keys.filter((key) => key.substring(0, namespace.length) === namespace);
  },
};
