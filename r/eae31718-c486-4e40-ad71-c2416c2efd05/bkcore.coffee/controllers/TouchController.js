// Generated by CoffeeScript 1.7.1

/*
  TouchController (stick + buttons) for touch devices
  Based on the touch demo by Seb Lee-Delisle <http://seb.ly/>
  
  @class bkcore.controllers.TouchController
  @author Thibaut 'BKcore' Despoulain <http://bkcore.com>
 */

class Vec2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }

  substract(vec) {
    this.x -= vec.x;
    this.y -= vec.y;
    return this;
  }

  copy(vec) {
    this.x = vec.x;
    this.y = vec.y;
    return this;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
}

class TouchController {
  static isCompatible() {
    return 'ontouchstart' in document.documentElement;
  }

  constructor(dom, stickMargin = 200, buttonCallback = null) {
    this.dom = dom;
    this.stickMargin = stickMargin;
    this.buttonCallback = buttonCallback;
    this.active = true;
    this.touches = null;
    this.stickID = -1;
    this.stickPos = new Vec2(0, 0);
    this.stickStartPos = new Vec2(0, 0);
    this.stickVector = new Vec2(0, 0);

    this.dom.addEventListener('touchstart', (e) => this.touchStart(e));
    this.dom.addEventListener('touchmove', (e) => this.touchMove(e));
    this.dom.addEventListener('touchend', (e) => this.touchEnd(e));
  }

  touchStart(event) {
    if (!this.active) return;

    for (const touch of event.changedTouches) {
      if (this.stickID < 0 && touch.clientX < this.stickMargin) {
        this.stickID = touch.identifier;
        this.stickStartPos.set(touch.clientX, touch.clientY);
        this.stickPos.copy(this.stickStartPos);
        this.stickVector.set(0, 0);
        continue;
      }

      if (typeof this.buttonCallback === 'function') {
        this.buttonCallback(true, touch, event);
      }
    }

    this.touches = event.touches;
  }

  touchMove(event) {
    event.preventDefault();

    if (!this.active) return;

    for (const touch of event.changedTouches) {
      if (this.stickID === touch.identifier && touch.clientX < this.stickMargin) {
        this.stickPos.set(touch.clientX, touch.clientY);
        this.stickVector.copy(this.stickPos).substract(this.stickStartPos);
        break;
      }
    }

    this.touches = event.touches;
  }

  touchEnd(event) {
    if (!this.active) return;

    this.touches = event.touches;

    for (const touch of event.changedTouches) {
      if (this.stickID === touch.identifier) {
        this.stickID = -1;
        this.stickVector.set(0, 0);
        break;
      }

      if (typeof this.buttonCallback === 'function') {
        this.buttonCallback(false, touch, event);
      }
    }
  }
}

/*
  Exports
  @package bkcore
*/

const exports = exports || this;

exports.bkcore || (exports.bkcore = {});

const _base = exports.bkcore;

_base.controllers || (_base.controllers = {});

exports.bkcore.controllers.TouchController = TouchController;
