class EngineGameCanvas {
  constructor(public canvas: HTMLCanvasElement = null, public context2D: CanvasRenderingContext2D = null) {}

  public backBuffer: OffscreenCanvas = null;
  public backBufferContext2D: CanvasRenderingContext2D = null;

  public initialize(canvasId: string, width: number, height: number): void {
    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
    this.context2D = this.canvas.getContext("2d");
    this.backBuffer = new OffscreenCanvas(width, height);
    this.backBufferContext2D = this.backBuffer.getContext("2d");
  }

  public beginDraw(): void {
    this.backBufferContext2D.clearRect(0, 0, this.backBuffer.width, this.backBuffer.height);
    this.context2D.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  public endDraw(): void {
    this.context2D.drawImage(this.backBuffer, 0, 0, this.backBuffer.width, this.backBuffer.height, 0, 0, this.canvas.width, this.canvas.height);
  }
}

const EnjineKeys = {
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  Left: 37,
  Up: 38,
  Right: 39,
  Down: 40,
};

class EnjineKeyboardInput {
  private pressedKeys: { [key: number]: boolean } = {};

  public initialize(): void {
    document.onkeydown = (event) => this.keyDownEvent(event);
    document.onkeyup = (event) => this.keyUpEvent(event);
  }

  public isKeyDown(keyCode: number): boolean {
    return this.pressedKeys[keyCode] || false;
  }

  private keyDownEvent(event: KeyboardEvent): void {
    this.pressedKeys[event.keyCode] = true;
    this.preventScrolling(event);
  }

  private keyUpEvent(event: KeyboardEvent): void {
    this.pressedKeys[event.keyCode] = false;
    this.preventScrolling(event);
  }

  private preventScrolling(event: KeyboardEvent): void {
    if (event.keyCode >= 37 && event.keyCode <= 40) {
      event.preventDefault();
    }
  }
}

class EnjineResources {
  public images: { [name: string]: HTMLImageElement } = {};
  public sounds: { [name: string]: Audio[] } = {};

  public destroy(): void {
    delete this.images;
    delete this.sounds;
  }

  public addImage(name: string, src: string): EnjineResources {
    const image = new Image();
    this.images[name] = image;
    image.src = src;
    return this;
  }

  public addImages(images: { name: string, src: string }[]): EnjineResources {
    images.forEach((image) => {
      this.images[image.name] = new Image();
      this.images[image.name].src = image.src;
    });
    return this;
  }

  public clearImages(): EnjineResources {
    delete this.images;
    this.images = {};
    return this;
  }

  public removeImage(name: string): EnjineResources {
    delete this.images[name];
    return this;
  }

  public addSound(name: string, src: string, channels: number = 3): EnjineResources {
    this.sounds[name] = [];
    this.sounds[name].index = 0;
    channels = channels || 3;
    for (let i = 0; i < channels; i++) {
      this.sounds[name][i] = new Audio(src);
    }
    return this;
  }

  public clearSounds(): EnjineResources {
    delete this.sounds;
    this.sounds = {};
    return this;
  }

  public removeSound(name: string): EnjineResources {
    delete this.sounds[name];
    return this;
  }

  public playSound(name: string, loop: boolean = false): EnjineResources {
    if (this.sounds[name].index >= this.sounds[name].length) {
      this.sounds[name].index = 0;
    }
    const sound = this.sounds[name][this.sounds[name].index];
    if (loop) {
      sound.addEventListener("ended", this.loopCallback, false);
    }
    sound.play();
    this.sounds[name].index++;
    return this;
  }

  private loopCallback = (): void => {
    this.currentTime = -1;
    this.play();
  }
}

class EnjineDrawable {
  public zOrder: number = 0;
}

class EnjineGameStateContext {
  constructor(public state: EnjineGameState = null) {
    if (state != null) {
      this.state.enter();
    }
  }

  public changeState(state: EnjineGameState): void {
    if (this.state != null) {
      this.state.exit();
    }
    this.state = state;
    this.state.enter();
  }

  public update(deltaTime: number): void {
    this.state.checkForChange(this);
    this.state.update(deltaTime);
  }

  public draw(canvas: EngineGameCanvas): void {
    this.state.draw(canvas);
  }
}

class EnjineGameState {
  public enter(): void {}
  public exit(): void {}
  public update(deltaTime: number): void {}
  public draw(canvas: EngineGameCanvas): void {}
  public checkForChange(context: EnjineGameStateContext): void {}
}

class EnjineGameTimer {
  constructor(public framesPerSecond: number = 1000 / 30, public lastTime: number = 0, public updateObject: EnjineGameTimer = null, public intervalFunc: NodeJS.Timeout = null) {}

  public start(): void {
    this.lastTime = (new Date).getTime();
    const timer = this;
    this.intervalFunc = setInterval(function () { timer.tick() }, this.framesPerSecond);
  }

  public tick(): void {
    if (this.updateObject != null) {
      const currentTime = (new Date).getTime();
      const deltaTime = (currentTime - this.lastTime) / 1000;
      this.lastTime = currentTime;
      this.updateObject.update(deltaTime);
    }
  }

  public stop(): void {
    clearInterval(this.intervalFunc);
  }
}

class EnjineDrawableManager {
  constructor(public unsorted: boolean = true, public objects: EnjineDrawable[] = []) {}

  public add(drawable: EnjineDrawable): void {
    this.objects.push(drawable);
    this.unsorted = true;
  }

  public addRange(drawables: EnjineDrawable[]): void {
    this.objects = this.objects.concat(drawables);
    this.unsorted = true;
  }

  public clear(): void {
    this.objects.splice(0, this.objects.length);
  }

  public contains(drawable: EnjineDrawable): boolean {
    for (let i = this.objects.length; i--;) {
      if (this.objects[i] === drawable) {
        return true;
      }
    }
    return false;
  }

  public remove(drawable: EnjineDrawable): void {
    const index = this.objects.indexOf(drawable);
    if (index > -1) {
      this.objects.splice(index, 1);
    }
  }

  public removeAt(index: number): void {
    this.objects.splice(index, 1);
  }

  public removeRange(start: number, end: number): void {
    this.objects.splice(start, end);
  }

  public removeList(drawables: EnjineDrawable[]): void {
    for (let i = 0, j = 0, k = 0; k < drawables.length; k++) {
      for (j = 0; j < this.objects.length; j++) {
        if (this.objects[j] === drawables[k]) {
          this.objects.splice(j, 1);
          drawables.splice(k, 1);
          k--;
          break;
        }
      }
    }
  }

  public update(deltaTime: number): void {
    for (let i = 0; i < this.objects.length; i++) {
      if (this.objects[i].update) {
        this.objects[i].update(deltaTime);
      }
    }
  }

  public draw(canvas: EngineGameCanvas, camera: EnjineCamera = null): void {
    if (this.unsorted) {
      this.unsorted = false;
      this.objects.sort((a, b) => a.zOrder - b.zOrder);
    }
    for (let i = 0; i < this.objects.length; i++) {
      if (this.objects[i].draw) {
        this.objects[i].draw(canvas, camera);
      }
    }
  }
}

class EnjineCamera {
  constructor(public x: number = 0, public y: number = 0) {}
}

class EnjineSprite extends EnjineDrawable {
  constructor(public image: HTMLImageElement = null, public x: number = 0, public y: number = 0) {
    super();
  }

  public draw(canvas: EngineGameCanvas, camera: EnjineCamera = null): void {
    if (camera != null) {
      x = x - camera.x;
      y = y - camera.y;
    }
    canvas.context2D.drawImage(this.image, this.x, this.y);
  }
}

class EnjineSpriteFont extends EnjineDrawable {
  constructor(
    public image: HTMLImageElement,
    public letters: { [charCode: number]: { x: number, y: number } },
    public letterWidth: number,
    public letterHeight: number,
    public strings: string[]
  ) {
    super();
  }

  public draw(canvas: EngineGameCanvas, camera: EnjineCamera = null): void {
    if (camera != null) {
      x = x - camera.x;
      y = y - camera.y;
    }
    for (let i = 0; i < this.strings.length; i++) {
      for (let j = 0; j < this.strings[i].length; j++) {
        const charCode = this.strings[i].charCodeAt(j);
        const letter = this.letters[charCode];
        if (letter) {
          canvas.context2D.drawImage(this.image, letter.x, letter.y, this.letterWidth, this.letterHeight, this.x + j * this.letterWidth, this.y, this.letterWidth, this.letterHeight);
        }
      }
    }
  }
}

class EnjineFrameSprite extends EnjineSprite {
  constructor(
    public frameWidth: number = 0,
    public frameHeight: number = 0,
    public frameX: number = 0,
    public frameY: number = 0,
    public image: HTMLImageElement = null,
    public x: number = 0,
    public y: number = 0
  ) {
    super(image, x, y);
  }

  public draw(canvas: EngineGameCanvas, camera: EnjineCamera = null): void {
    if (camera != null) {
      x = x - camera.x;
      y = y - camera.y;
    }
    canvas.context2D.drawImage(this.image, this.frameX, this.frameY, this.frameWidth, this.frameHeight, this.x, this.y, this.frameWidth, this.frameHeight);
  }
}

class EnjineAnimationSequence {
  constructor(
    public startRow: number = 0,
    public startColumn: number = 0,
    public endRow: number = 0,
    public endColumn: number = 0,
    public singleFrame: boolean = false
  ) {}
}

class EnjineAnimatedSprite extends EnjineFrameSprite {
  constructor(
    public lastElapsed: number = 0,
    public framesPerSecond: number = 0.05,
    public currentSequence: EnjineAnimationSequence = null,
    public looping: boolean = false,
    public playing: boolean = false,
    public columns: number = 0,
    public rows: number = 0,
    public sequences: { [name: string]: EnjineAnimationSequence } = {}
  ) {
    super(0, 0, 0, 0, null, 0, 0);
  }

  public update(deltaTime: number): void {
    if (!this.currentSequence.singleFrame && this.playing && (this.lastElapsed -= deltaTime) <= 0) {
      this.lastElapsed = this.framesPerSecond;
      this.frameX += this.frameWidth;
      if (this.frameX > this.image.width - this.frameWidth && (this.frameX = this.currentSequence.startColumn * this.frameWidth, this.frameY += this.frameHeight, this.frameY > this.image.height - this.frameHeight)) {
        this.frameY = 0;
      }
      if (this.frameX > this.currentSequence.endColumn * this.frameWidth && this.frameY == this.currentSequence.endRow * this.frameHeight) {
        this.playing = false;
      }
    }
  }

  public playSequence(name: string, loop: boolean = false): void {
    this.playing = true;
    this.looping = loop;
    this.currentSequence = this.sequences[name];
    this.frameX = this.currentSequence.startColumn * this.frameWidth;
    this.frameY = this.currentSequence.startRow * this.frameHeight;
  }

  public stopLooping(): void {
    this.looping = false;
  }

  public stopPlaying(): void {
    this.playing = false;
  }

  public setFrameWidth(width: number): void {
    this.frameWidth = width;
    this.columns = Math.floor(this.image.width / width);
  }

  public setFrameHeight(height: number): void {
    this.frameHeight = height;
    this.rows = Math.floor(this.image.height / height);
  }

  public setColumnCount(count: number): void {
    this.frameWidth = Math.floor(this.image.width / count);
    this.columns = count;
  }

  public setRowCount(count: number): void {
    this.frameHeight = Math.floor(this.image.height / count);
    this.rows = count;
  }

  public addExistingSequence(name: string, sequence: EnjineAnimationSequence): void {
    this.sequences[name] = sequence;
  }

  public addNew
